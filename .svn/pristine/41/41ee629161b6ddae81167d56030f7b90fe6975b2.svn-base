package src.src.model;

import static org.junit.Assert.*;
import src.src.utilities.Mode;
import org.junit.Before;
import org.junit.*;

import src.src.views.IListener;
import src.src.views.Player;

/**
 * Only tests methods that are not already covered by GameBoardTest
 */

public class GameHumanvsHumanTests {
  
  @Test
  public void testSingletonBehavior() {
    GameMode newGame = GameModeHumanvsHuman.getModelInstance(1);
    GameMode secondNewGame = GameModeHumanvsHuman.getModelInstance(3);
    assertEquals(newGame, secondNewGame);
  }
  
  @Test
  public void testFactoryMethod_Default() {
    GameMode model = GameModel.getGameModel(Mode.HUMAN);
    assertEquals(model.getNumberOfColumnsOnBoard(), 7);
  }
  
  @Test
  public void testValidNumberOfColumns() {
    GameModeHumanvsHuman newGame = GameModeHumanvsHuman.getModelInstance(3);
    assertEquals(newGame.getNumberOfColumnsOnBoard(), 3);
  }
  
  @Test
  public void testGetDefaultForInvalidNumberOfColumns() {
    GameModeHumanvsHuman newGame = GameModeHumanvsHuman.getModelInstance(0);
    assertEquals(newGame.getNumberOfColumnsOnBoard(), 7);
  }
  
  @Test
  public void testBoardBuilderForSevenColumns() {
    GameModeHumanvsHuman newGame = GameModeHumanvsHuman.getModelInstance(7);
    assertEquals(newGame.getNumberOfColumnsOnBoard(), 7);
  }

  @Test
  public void testFactoryMethodForHumanMode() {
    GameMode model = GameModel.getGameModel(Mode.HUMAN, 4);
    assertEquals(model.getNumberOfPlayers(), 2);
  }
  
  @Test
  public void testRegister_TwoPlayers() {
    GameMode model = GameModel.getGameModel(Mode.HUMAN, 7);
    IListener listener1 = new Player(model);
    IListener listener2 = new Player(model);
    assertEquals(listener1.getPiece(), 'Y');
    assertEquals(listener2.getPiece(), 'R');
  }
  
  @Test(expected = UnsupportedOperationException.class)
  public void testRegister_ThreePlayers() {
    GameMode model = GameModel.getGameModel(Mode.HUMAN, 7);
    new Player(model);
    new Player(model);
    IListener listener3 = new Player(model);
    assertNull(listener3);
  }
  
  /*Player1 and Player2 alternate*/
  @Test
  public void testTurns_ValidPlay() {
    GameMode model = GameModel.getGameModel(Mode.HUMAN, 7);
    IListener listener1 = new Player(model);
    IListener listener2 = new Player(model);
    model.registerListener(listener1, true);
    model.registerListener(listener2, true);
    assertTrue(model.selectColumnForMove(listener1, 1));
    assertTrue(model.selectColumnForMove(listener2, 1));
  }
  
  /*
    Player1's turn - makes invalid move.
    Player1 should be able to play again.
  */
  @Test
  public void testTurnNoAlternate_InvalidPlay() {
    GameMode model = GameModel.getGameModel(Mode.HUMAN, 7);
    IListener listener1 = new Player(model);
    IListener listener2 = new Player(model);
    model.registerListener(listener1, true);
    model.registerListener(listener2, true);
    model.selectColumnForMove(listener1, 9);
    assertTrue(model.selectColumnForMove(listener1, 3));
  }
  
  /*Player1 plays twice consecutively. Should be false.*/
  @Test
  public void testTurns_InvalidPlay() {
    GameMode model = GameModel.getGameModel(Mode.HUMAN, 7);
    IListener listener1 = new Player(model);
    IListener listener2 = new Player(model);
    model.registerListener(listener1, true);
    model.registerListener(listener2, true);
    assertTrue(model.selectColumnForMove(listener1, 1));
    assertFalse(model.selectColumnForMove(listener1, 1));
  }
  
  @Test
  public void testBeginGameBeforePlayer2Registers() {
    GameMode model = GameModel.getGameModel(Mode.HUMAN, 7);
    IListener listener1 = new Player(model);
    model.registerListener(listener1, true);
    assertFalse(model.selectColumnForMove(listener1, 1));
  }
  
  @Test
  public void testResetGameNotInProgress() {
    GameMode model = GameModel.getGameModel(Mode.HUMAN, 7);
    IListener listener1 = new Player(model);
    IListener listener2 = new Player(model);
    model.registerListener(listener1, true);
    model.registerListener(listener2, true);
    assertTrue(model.selectColumnForMove(listener1, 1));
    assertTrue(model.selectColumnForMove(listener2, 2));
    assertTrue(model.selectColumnForMove(listener1, 0));
    assertTrue(model.selectColumnForMove(listener2, 3));
  }

  @Test
  public void testPlayer1Player2TwoTurnsEach() {
    GameMode model = GameModel.getGameModel(Mode.HUMAN, 7);
    IListener listener1 = new Player(model);
    IListener listener2 = new Player(model);
    model.registerListener(listener1, true);
    model.registerListener(listener2, true);
    assertTrue(model.selectColumnForMove(listener1, 1));
    assertFalse(model.selectColumnForMove(listener1, 1));
  }
  
  @Test (expected=UnsupportedOperationException.class)
  public void testResetGameInProgress() {
    GameMode model = GameModel.getGameModel(Mode.HUMAN, 7);
    IListener listener1 = new Player(model);
    IListener listener2 = new Player(model);
    model.registerListener(listener1, true);
    model.registerListener(listener2, true);
    model.selectColumnForMove(listener1, 1);
    model.selectColumnForMove(listener2, 1);
    model.resetGame(true);
  }
  
  @After
  public void cleanUp() {
    GameMode newGame = GameModeHumanvsHuman.getModelInstance(1);
    ((GameModeHumanvsHuman)newGame).setSingleInstanceToNull();
  }
  
}
